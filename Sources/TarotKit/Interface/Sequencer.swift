//
//  Exporter.swift
//
//
//  Created by Stefan Urbanek on 29/12/2021.
//

// TODO: Rename to SequentialWriter
// TODO: Create analogous counterpart: SequentialReader

/*
 
 EXPORT (flatten, untalngle the graph)

     NAME cards
     WHERE <PREDICATE>
         TRAIT = CARDS
     PATH BY name
     FLATTEN
         requires: requires.name
         amplifies: amplifies.name
         inhibits: inhibits.name
         type: type.name
         NAME: REFERENCE.ATTRIBUTE â†’ scalar/list depending on the target
 
 */

/// Reference to an attribute in a related node.
public class AttributeReference {
    public let linkLabel: String
    public let targetAttribute: String
    
    public init(linkLabel: String, targetAttribute: String){
        self.linkLabel = linkLabel
        self.targetAttribute = targetAttribute
    }
}

/// Description a sequence generated by a ``Sequencer``.
///
public class SequenceDescription {
    /// Rule to select objects in the graph
    let predicate: ObjectPredicate
    
    let targetAttributes: [String:AttributeReference]
    
    public init(predicate: ObjectPredicate, targetAttributes: [String:AttributeReference]) {
        self.predicate = predicate
        self.targetAttributes = targetAttributes
    }
    
}


/// Sequencer is an object that creates a sequence of records from a
/// selection of graph objects. The structure of all records is the same.
///
/// Sequencer is used to generate output that can be processed in a sequential
/// fashion without recursion and without need to look-up additional information.
/// Each record of the sequence is supposed to be self-contained.
///
/// Output of the sequencer might and very likely will contain redundant
/// information.
///
/// Example use of a sequencer output is merging records with presentation
/// templates.
///
/// - Note: It is caled Sequencer not a Serializer to distinguish the
/// possibility of a reversible operation. Usually serialization process is
/// expected to have a deserialization counterpart.
///
public class Sequencer {
    public let memory: GraphMemory
    
    public init(memory: GraphMemory) {
        self.memory = memory
    }
    
    public func sequence(description: SequenceDescription) {
        let nodes = memory.filterNodes(predicate: description.predicate)
        
        for node in nodes {
           // FIXME: Continue here
            fatalError("Not implemented. Continue here.")
        }
    }
    
    public func extract(node: Node, description: SequenceDescription) {
        
    }
}
